CS 490 Exam 1 Study Guide
GENERAL GUIDELINES:  
Review your notes and the textbook.  Use the Power Points as a guideline for 
what to study, but don’t limit your study to the Power Points alone.  
Information from any Power Points that aren’t discussed in class won’t be on the
test.  Check out the summary at the end of each chapter as well as the chapter 
review questions..

Review homework; be able to work similar problems, know the material in written answers.
Learn to prioritize; not every item is of equal importance.  For example, 
understanding concurrency and the need for mutual exclusion is more important 
than knowing what a mailbox is.  If you have questions about any of the items 
below, please ask in class on Tuesday or email me about them.  If are unsure 
about something other students probably will be as well and it will be helpful 
to everyone to discuss it in class.

Information comes from the book Operating Systems Internals and Design Principles
8th Edition by William Stallings

********************************************************************************
Chapter 1: Computer System Overview
********************************************************************************
Program Counter (PC) - holds the address of the next instruction to be fetched.
Unless instructed otherwise, the processor always increments the PC after each
instruction fetch.

Instruction Register - The register that contains the instruction that will currently
be executed.

Memory Address Register (MAR) - an internal register of the processor, which specifies
the address in memory for the next read/write.

Memory Buffer Register (MBR) - an internal register of the processor, which contains
the data to be written into memory or which receives the data read from memory.

*********************************
Basic instruction execution cycle
*********************************
Fetch -> Decode -> Execute -> Store (writeback)

*********************************
execution cycle with interrupts
*********************************
Fetch -> Decode -> Execute -> Check for interrupts
                      |
                    Halt

Motivation for Multi-programming - multi-programming allows the processor to be more
efficient by reducing the processor's idle time.  Multi-programming allows one process
to run while another process is blocked (doing an I/O operation).

Interrupts - provided primarily as a way to improve processor utilization.

***********************
4 Classes of Interrupts
***********************
Program - generated by an illegal instruction such as dividing by 0, arithmetic overflow,
reference outside a user's allowed memory space, etc.

Timer - Timer within processor that allows the OS to perform certain functions on a regular basis.

I/O - generated by an I/O controller, to signal normal completion of an operation or to signal
a variety of error conditions.

Hardware failure - power, memory parity error, etc.

****************
Memory Hierarchy
****************
Memory Hierarchy from fastest (most expensive per bit) to slowest (cheapest per bit)
1. Onboard memory: registers, cache, main memory
2. Outboard memory: HDD, optical drive
3. Off line storage: tape drive

Hit ratio - the fraction of all memory accesses that are found in the faster memory (cache)
Ts = H * T1 + ((1 - H) * (T1 + T2))
where H is the hit ratio, T1 is time to access fast memroy, T2 is time to access slow memory

Purpose of cache - Cache is used to allow faster memroy access.  cache memory is
used by placing data that is likely to be accessed in the fast memory (cache), 
allowing it to be accessed faster.

Principle of Locaility - memory references tend to cluster around certain subsets of total 
memory belonging to a program

**************************
Direct Memory Access (DMA)
**************************
The DMA is used to improve performance in a mult-programmed computer system by allowing
the reading/writing of data to an I/O device to be performed by a seperate module and not
the CPU.

The DMA module performs the I/O operations while the processor continues with other work.

*****************************************************
Symmetric Multiprocessors (SMP) vs multicore computer
*****************************************************
SMP and multicore computers both are used to provide parallelism, both divide up work among
the system

SMP has two or more processors connected by a bus.  Processors share main memory and I/O devices.
All processors can perform the same instructions, hence the term symmetric.

Multicore computer (Chip multiprocessor) - combines two or more processors (called cores) on a
single piece of silicon (called a die).  Each core consists of all the components of an independent
processor, such as registers, ALU, pipeline hardware, and control unit.  Does not need a bus to
communicate with cores.

********************************************************************************
Chapter 2: Operating System Overview
********************************************************************************

*************************
Three Objectives of an OS
*************************
1. Convenience - Hardware/software marry/manage user interface
2. Efficiency - control of system resources, schedule tasks and processes
3. Ability to evolve - change with hardware, new services, fixes

OS Kernel - Intermediate step between software applications (processes) and the system's hardware.
Contains the most frequently used functions in the OS and, other parts of the OS currently in use.

*******************************************************************************************
Important features (originally introduced in batch processing) for multi-programmed systems
*******************************************************************************************
1.  Memory Protection - The user program must not alter the memory area containing the monitor
2.  Timer - used to prevent a single process from monopolizing the system. If the timer for a
    job expires, the program is stopped and the monitor resumes control.
3.  Privileged Instructions - Prevents user programs from doing certain instructions that may
    cause problems such as an I/O instruction. If the user program wishes to do a privileged
    instruction, it must request that the monitor perform the operation.
4.  Interrupts - Allows the flow of control from systems to user and vice versa.

User Mode - user programs execute in this mode.  Certain areas of memory are protected from use
and certain instructions may not be executed.

Kernel mode - Monitor executes in this mode.  Privileged instructions may be executed and protected
areas of memory can be accessed.

*********************************************
batch multiprocessing vs time sharing systems
*********************************************
batch multiprocessing is used to maximize the processor's use, by having one 
process work while another process waits for I/O.

Time sharing systems are used for interactive jobs while processor time is shared 
between multiple users.  The OS executes each user programs in short bursts giving 
the illusion of speed.

time slicing - at each clock interrupt OS regains control and could assign the processor
to another user in a time sharing system.

Process - a program in execution.  A collection of one or more threads and associated
system resources.

execution context (process state) - the internal data by which the OS is able to 
supervise and control the process.

Thread - a process can be broken down into multiple concurrent threads that execute 
cooperatively to perform the work of the process.

***********************************
interleaved vs overlapped execution
***********************************
Interleaving execution - interleaving the execution steps of each process via time slices:
only one process runs at a time, and if it does not complete during its time slice, 
it is paused, another process begins or resumes, and then later the original process 
is resumed. In this way multiple processes are part-way through execution at a single 
instant, but only one process is being executed at that instant.

Overlapping execution - overlapping of execution on a multiprocessor computer. Processes 
are literally executed at the same time, but with different processors.

********************************************************************************
Chapter 3: Processes
********************************************************************************
Process VS Program
A process is an instance of a program (currently running) and a program is a set of 
instructions to perform a task

*********************
Process Control Block
*********************
Process Control Block (PCB) - a data structure that contains sufficient information 
about a process so that the process can be interrupted and later resumed as if the 
interruption had not occurred.

Information found on the PCB includes: Identifier, State, Priority, Program Counter (PC),
Memory Pointers, Context data, I/O Status Information, and Accounting information

**************
Process States
**************
New - new process is created to execute a program, but not yet loaded into main memory.  
Reasons for new processes: new batch job, interactive log-on (terminal), created by 
the OS to provide a service, spawned by existing process.

Ready - processes move from new to ready when the OS is prepared to take on an additional 
process.  The process is prepared to execute when given the opportunity.  
Running -> Ready usually caused by taking the maximum allowed time to for uninterrupted execution.

Running - the OS chooses a process from the ready state to run.  The process is currently being 
executed.  For this chapter, assume a single processor, so at most one process at a time can 
be in this state.

Blocked/Waiting - A process that cannot execute until some event occurs, such as the completion of an 
I/O operation.  Has to go back to ready state, cannot go back to run state directly.

Exit - A process that has been released from the pool of executable processes by the OS because it either 
halted or aborted for some reason.

***************
Supervisor Call
***************
Supervisor call (system call) - A user program can use a supervisor call to execute a function
that is part of the OS.  Transfers to a routine that is part of the OS's code. I/O operation

System calls provide an essential interface between a process and the OS. A system call is how
a program requests a service from an OS's kernal. This may include hardware-related services (for
example, accessing a hard disk drive), creation and execution of new processes, and communication with
integral services such as processs scheduling.

*********************************************
Mechanisms for interrupting process execution
*********************************************
1.  Interrupt - External to the execution of the current instruction.

    Clock Interrupt - OS determines if current running process has been running for the maximum
    allowable unit of time, referred to as a time slice.  If so, the process must be switched
    to a ready state and another process dispatched.

    I/O interrupt - OS determines what I/O action has occurred, if it constitutes an event that one
    or more processes are waiting, the OS moves all corresponding blocked processes to the ready state.

    Memory Fault - The processor encounters a virtual memory address reference for a word that is not
    in main memory.  The OS must bring the memory containing the reference from secondary memory to
    main memory.  Process with the memory fault is placed in a blocked state, the OS performs a process
    switch to resume execution of another process. After the desired block is brought into memory, that
    process is placed in the Ready State.

2.  trap - handles errors and exections such as breakpoints, divide by zero exections, and invalid
    memory accesses.  Associated with the execution of of the current instruction.

3.  Supervisor call (system call) - Handles calls to operating system functions

*****************************
Mode Switch VS Process Switch
*****************************
Process Switch - changes the state of a process (ready, running, exit, etc).  For example, a user
process is running and an instruction is executed that requests an I/O  operation such as a file
open.  This call results in transfer to a routine that is part of the OS code. The user of a
system call may place the user process in the Blocked State.  Also referred to as a context switch.

Mode Switch - Switches from user mode (less privileged) to kernel mode (more privileged).  Occurrs
from an interrupt.

A mode switch may occur without chaning the state of the process that is currently in the running
state. The process switch, which involves a state change, requires more effort than a mode switch.

***********************************
UNIX User Running VS Kernel Running
***********************************
The user running state means that the process is executing in user mode.  The kernel running state
means that the process is running in kernal mode.

********************************************************************************
Chapter 4: Processes and Threads
********************************************************************************
Relation between process and thread - processes are made up of one or more threads.  The unit of
dispatching is usually referred to as a thread, the unit of ownership is usually referred to as
a process or task.

Multithreading - the ability of an OS to support multiple, concurrent paths of execution within
a single process.

********************************************************
Uses for threads in a single-user multiprocessing system
********************************************************
Foreground and background work - for example in a spreadsheet program, one thread could display
menus and read user input, while another thread executes user commands and updates the spreadsheet.
This arrangment often increases the perceived speed of the application by allowing the program
to prompt for the next command before the previous command is complete.

Asynchronous processing - Asychronous elements in the program can be implemented as threads.

Speed of execution - A multithreaded process can compute one batch of data while reading the next
batch from a device.

Modular Program Structure - Programs involved in a variety of activities or variety of sources
and destinations of input and output may be easier to design and implement using threads.

*******************************************************
Threads VS Application of Multiple Cooperating Programs
*******************************************************
Creating new threads from an existing process takes less time than creating new processes. It also
takes less time to terminate a thread than a process, less time to switch between two threads within
the same process than to switch between two processes.  Threads can communicate faster and more
efficiently.

The seperate yet cooperating programs would not share a scope of variables and would be negatively
affected by any mutual exclusion structure.

******************************************************
Kernel-Level Threads (KLT) VS User-Level Threads (ULT)
******************************************************
ULT - all of the work of thread management is done by the application and the kernel is not aware
of the existence of threads.  The kernel schedules the process, the process schedules these threads.

KLT - all of the work of thread management is done by the kernel.  Scheduling of threads is done
by the OS scheduler.  Most common types of thread.  KLT do NOT have kernel level privileges.

KLT Advantages: Can take advantage of multi-processing. If one thread is blocked, another thread
can be scheduled from the same process.  

KLT Disadvantages: transfer of control from one thread to another within the same process requires
a mode switch to the kernel.

ULT Advantages:  Can run on any OS, scheduling can be application specific, thread switching
does not require kernel mode privileges

ULT Disadvantages: System calls are typically blocking, meaning that when a thread makes a
system call, all threads within the process are blocked.  Cannot take advantage of multi-
processing.

Jacketing - for ULT it is a technique that converts a blocking system call into a nonblocking
system call.

*********************
Windows Standby State
*********************
Standby State - a state that a thread can possess where in it waits for its soon to be processor
to become freed and available for use.

********************************************************************************
Chapter 5: Concurrency: Mutual Exclusion and Synchronization
********************************************************************************
Multiprogramming - the management of multiple processes within a uniprocessor system

Multiprocessing - the management of multiple processes within a multiprocessor.  In this,
a computer uses more than one CPU at a time

*********************
Table 5.1 Definitions
*********************
Atomic operation - The sequence of instruction is guaranteed to execute as a group, or
not execute at all, having no visible effect on the system state.  Atomicity guarantees
isolation from concurrent processes.

Critical Section - A section of code within a process that requires access to shared resources
and that must not be executed while another process is in a corresponding section of code.

Deadlock - A situation in which two or more processes are unable to proceed because each is
waiting for one of the others to do something

Mutual Exclusion - The requirement that when one process is in a critical section that accesses
shared resources, no other process may be in a critical section that accesses any of those shared
resources

Race Condition - A situation in which multiple threads threads or processes read and write a shared
data item and the final result depends on the relative timing of their execution.

Starvation - A situation in which runnable process is overlooked indefinitely by the scheduler;
although it is able to proceed, it is never choosen.

***********************************************************************************
How Interleaved or Overlapped Execution of Critical Sections Cause Data Incoherence
***********************************************************************************
Page 202 to 204 Examples
Examples in homework
Both schemes are effected by the same problem and thus can be solved by the same solution approach,
only differing on implementation.

*****************************************************
Hardware techniques for guaranteeing Mutual Exclusion
*****************************************************
Interrupt Disabling - to guarantee mutual exclusion, it is sufficient to prevent a process from
being interrupted.  This capability can be provided in the form of primitives defined by the OS
kernel for disabling and enabling interrupts.  Only on a uniprocessor system

Disadvantage is that the efficiency of execution could be noticeably degraded because the processor
is limited in its ability to interleave processes.

Special Machine Instructions - Performs several machine instructions that carry out two actions
automically.  This approach utilizes busy waiting, starvation (no ordering for the busy waiting
processes) and deadlock is possible.

Disadvantages are busy waiting is employed: thus, while a process is waiting for access to a critical
section, it continues to consume processor time.  Starvation is possible: when a process leaves a
critical section and more than one process is waiting, the selection of a waiting process is
arbitrary.  Thus, some process could indefinitely be denied access.  Deadlock is also possible: on
a single-processor system, P1 executes a special instruction and enters a critical section, P1 is then
interrupted to give the processor to P2, which has a higher priority.  If P2 attempts to get a resource
currently used by P1, it is denied access.

**********
Semaphores
**********
Semaphore - an integer value used for signaling among processes. Only three operations may be performed
on a semaphore, all of which are atomic: initalizatize, decrement, and increment.  Decrement - could block
a a process if it is less than 0, increment - could unblock a process if it becomes 0 or greater.

Wait - decrements the semaphore value, if less than 0, the process that called the wait is blocked
signal - increments the semaphore value, if the value is less than or equal to 0, than a process
that was waiting to execute becomes unblocked.

Strong semaphore - uses FIFO policy for the queue of blocked proceeses
Weak semaphore - does not use FIFO, removal policy is not specified
Strong semaphores guarantee freedom from starvation, while weak semaphores do not

*************************
Producer/Consumer Problem
*************************
page 220
There are one or more producers (creators of data into a buffer) and one consumer who retrives the
data from the buffer one at a time.  One agent (consumer or producer) may access the buffer at a
time, and the consumer must not write to a full buffer and the consumer must not try to read from
an empty buffer.

Figure 5.9 page 222 - solution with semaphores

********
Monitors
********
The monitor is a programming language construct that provides the functionality of a semaphore
but easier to control.

Characteristics of a monitor:
1.  Local data variables can only be accessed by the monitor's procedures and not by any external
    procedure
2.  A process can enter the monitor by calling one of its procedures
3.  Only one process at a time can be executing in the monitor, any other processes trying to
    get access are blocked, waiting until the monitor is available

Condition variables - The way a monitor supports synchronization.  Contianed in and only accessible
by the monitor.  Has two types of functions:
cwait(c) - suspend execution of the calling process on condition c, monitor now available for use
by another process
csignal(c) - resume execution of the calling process blocked after a cwait on the same condition.
If there are several such processes, choose one of them; if none, do nothing.

If a process in a monitor signals and no task is waiting on the condition variable, the signal is
lost

***********************************
Message Passing and Synchronization
***********************************
Messages can be used for process synchronization by using the send(destination, message) and 
recieve(source, message) functions

1.  If a message has been previously sent, the message is received and execution continues
2.  If there is no waiting message, then either a. the process is blocked until message arrives
    or b. the process continues to execute, abandononing the attempt to receive.

************************************************
Blocking VS Non-Blocking message send or receive
************************************************
Blocking send/blocking receive - both the sender and receiver are blocked until the message is
delivered.  This combination allows for tight synchronization between processes.

Nonblocking send/blocking receive - Sender may continue on, receiver is blocked until the requested
message arrives.  Allows a process to send to or more messages to a variety of destinations as fast
as possible.  Process that must receive a message before it does any work is blocked until message
arrives.

Nonblocking send/nonblocking receive - Neither party needs to wait for the message to be received.

*********
mailboxes
*********
For indirect addressing where messages are not sent directly from the sender to the receiver, but to
a shared data structure consisting of queues that can temporarily hold messages, called a mailbox.
If a process needs to send a message to another process, it will send the message to the appropriate
mailbox, then the other process will pick up the message from the mailbox.

***********************
Readers/Writers Problem
***********************
Readers/Writers problem - A shared set of data in which there are many processes that only read the
data or only write to the data.  Has 3 conditions:
1.  Could have any number of readers reading the date at the same time
2.  Only one writer may write to the data at one time
3.  If a writer is writing to the data, no reader can read it

Study figure 5.22 on page 241

*********
UNIX Pipe
*********
| pipes output to another process
A pipe is a circular buffer that allows two processes to communicate on the producer/consumer
model.  It is first-in-first-out queue, written by one process and read by another.

********************************************************************************
Chapter 6: Deadlocks
********************************************************************************
A deadlock is a permanent blocking of a set of processes that either compete for system resources
or communicate with each other.  A set of processes is blocked awaiting an event (like the freeing
up of a resource) that can only be triggered by another blocked process.  It is permanent because
none of the events is ever triggered.
